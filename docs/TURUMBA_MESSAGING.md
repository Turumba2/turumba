# Turumba Messaging

This document describes the messaging capabilities of the Turumba platform in detail. For a high-level overview of the entire platform, see [What is Turumba?](./WHAT_IS_TURUMBA.md).

---

## Overview

Messaging is the core of Turumba. Everything else — accounts, contacts, roles — exists to support one goal: letting users send the right message, to the right person, through the right channel, at the right time.

The messaging system is powered by the **turumba_messaging_api** and is accessed through the **Turumba Gateway**. It covers five major areas:

1. [Messages](#1-messages) — Send, receive, and view messages
2. [Template Messages](#2-template-messages) — Reusable messages with variable placeholders
3. [Group Messaging](#3-group-messaging) — Bulk messaging to contact groups
4. [Scheduled Messages](#4-scheduled-messages) — Time-delayed message delivery
5. [Event Infrastructure](#5-event-infrastructure) — EventBus, Transactional Outbox, and RabbitMQ

> Delivery Channels — the connections to external messaging platforms — are documented separately in [Turumba Delivery Channels](./TURUMBA_DELIVERY_CHANNELS.md).

---

## 1. Messages

Messages are the fundamental unit of the messaging system. Every interaction — whether a single SMS, a group broadcast, or a scheduled delivery — is recorded as a message.

**Database:** PostgreSQL — messages are relational (FK to channels, contacts, accounts, users) and require ACID guarantees for status transitions. Channel-specific metadata is stored in JSONB columns.

### Message Data Model

```
messages (PostgreSQL)
├── id (UUID, PK)
├── account_id (UUID, indexed)         — tenant isolation
├── channel_id (UUID, nullable)        — which delivery channel was used
├── contact_id (UUID, nullable)        — the recipient or sender
├── sent_by_user_id (UUID, nullable)   — which team member initiated the send
├── group_message_id (UUID, FK, nullable) — parent group message if part of a bulk send
├── template_id (UUID, nullable)       — which template was used
├── direction (string)                 — "outbound", "inbound", or "system"
├── status (string, indexed)           — "queued", "sending", "sent", "delivered", "failed", "permanently_failed", "scheduled"
├── delivery_address (string)          — phone number, email, username, or platform ID
├── message_body (text)                — rendered message content
├── original_template (text, nullable) — raw template before variable substitution
├── scheduled_at (timestamp, nullable) — for scheduled messages
├── sent_at (timestamp, nullable)      — when handed off to provider
├── delivered_at (timestamp, nullable) — when provider confirmed delivery
├── failed_at (timestamp, nullable)    — when delivery failed
├── metadata (JSONB)                   — channel-specific data (SMS segment count, Telegram msg ID, email subject, etc.)
├── error_details (JSONB, nullable)    — provider error codes on failure
├── created_at (timestamp)
└── updated_at (timestamp)
```

### Message Types

| Type | Direction | Description |
|------|-----------|-------------|
| **Outbound** | Sent | A message sent from a Turumba user to a contact through a delivery channel |
| **Inbound** | Received | A message received from a contact through a connected delivery channel |
| **System** | Internal | Automated messages generated by the system (e.g., delivery failure notifications) |

### Message Statuses

Every outbound message moves through a status lifecycle:

```
Scheduled ──→ Queued → Sending → Sent → Delivered
                                   │
                                   └→ Failed → Retry → Sent
                                                 │
                                                 └→ Permanently Failed
```

| Status | Meaning |
|--------|---------|
| **Scheduled** | Queued for future delivery at `scheduled_at` time |
| **Queued** | Message accepted and waiting to be processed |
| **Sending** | Message is being transmitted to the delivery channel |
| **Sent** | Message handed off to the provider successfully |
| **Delivered** | Provider confirmed the message reached the recipient |
| **Failed** | Delivery failed (invalid number, provider error, etc.) |
| **Permanently Failed** | All retry attempts exhausted — delivery not possible |

### API Endpoints

| Method | Endpoint | Description |
|--------|----------|-------------|
| `POST` | `/v1/messages/` | Create a new message |
| `GET` | `/v1/messages/` | List messages (filtered, sorted, paginated) |
| `GET` | `/v1/messages/{id}` | Get a single message by ID |
| `PATCH` | `/v1/messages/{id}` | Update a message (primarily status transitions) |
| `DELETE` | `/v1/messages/{id}` | Delete a message |

All endpoints require authentication. List endpoint is scoped to the user's accounts via the gateway's `x-account-ids` header.

### Filtering and Sorting

Messages support the platform's standard filter syntax: `?filter=field:op:value&sort=field:order`

| Field | Allowed Filter Operations | Sortable |
|-------|--------------------------|----------|
| `id` | `eq` | No |
| `account_id` | `eq`, `in` | No |
| `channel_id` | `eq`, `in` | No |
| `contact_id` | `eq` | No |
| `direction` | `eq` | No |
| `status` | `eq`, `in` | Yes |
| `delivery_address` | `eq`, `contains`, `icontains` | No |
| `template_id` | `eq` | No |
| `group_message_id` | `eq` | No |
| `sent_by_user_id` | `eq` | No |
| `scheduled_at` | `ge`, `le`, `range` | Yes |
| `sent_at` | `ge`, `le`, `range` | Yes |
| `delivered_at` | `ge`, `le`, `range` | Yes |
| `created_at` | `ge`, `le`, `range` | Yes |
| `updated_at` | `ge`, `le`, `range` | Yes |

**Example queries:**
```bash
# All delivered outbound messages
GET /v1/messages/?filter=status:eq:delivered&filter=direction:eq:outbound&sort=created_at:desc

# Failed messages for a specific channel
GET /v1/messages/?filter=channel_id:eq:{uuid}&filter=status:in:failed,permanently_failed

# Messages to a specific contact, newest first
GET /v1/messages/?filter=contact_id:eq:{uuid}&sort=created_at:desc&limit=50

# Messages sent today
GET /v1/messages/?filter=created_at:ge:2026-02-08&sort=created_at:desc
```

### Message Detail

Each message record contains:

- **Content** — The message body (rendered, with template variables resolved)
- **Original template** — The raw template before variable substitution (if applicable)
- **Channel** — Which delivery channel was used
- **Contact** — The recipient or sender
- **Delivery address** — The phone number, username, email, or platform ID used
- **Status** — Current delivery status with timestamps for each transition
- **Direction** — Outbound or inbound
- **Metadata** (JSONB) — Channel-specific data (e.g., SMS segment count, Telegram message ID, email subject)
- **Error details** (JSONB) — If failed, the reason and provider error codes
- **Sent by** — Which team member initiated the message (for audit purposes)

---

## 2. Template Messages

Template messages are reusable message blueprints with variable placeholders that get replaced with contact-specific data at send time. They are essential for group messaging — every group message uses a template so each contact receives a personalized version.

**Database:** PostgreSQL — templates are relational (FK to accounts, referenced by messages via `template_id`) and benefit from text search on template body/name. Variable metadata and default values are stored in JSONB.

### Template Data Model

```
templates (PostgreSQL)
├── id (UUID, PK)
├── account_id (UUID, indexed)              — tenant isolation
├── name (string)                           — user-defined template name
├── body (text)                             — template text with {VARIABLE} placeholders
├── category (string, nullable, indexed)    — organizational category (e.g., "Onboarding", "Reminders")
├── channel_type (string, nullable, indexed) — restrict to a channel type, or null for any channel
├── language (string, nullable)             — e.g., "en", "am"
├── variables (JSONB)                       — auto-extracted variable names from body
├── default_values (JSONB)                  — fallback values per variable
├── fallback_strategy (string)              — "keep_placeholder", "use_default", "skip_contact"
├── approval_status (string, nullable)      — "pending", "approved", "rejected" (for WhatsApp, etc.)
├── external_template_id (string, nullable) — provider-side template ID
├── is_active (boolean)                     — whether the template is available for use
├── created_by_user_id (UUID, nullable)     — who created the template
├── created_at (timestamp)
└── updated_at (timestamp)
```

### How Templates Work

A template contains **static text** and **variable placeholders** using the `{VARIABLE_NAME}` syntax:

```
Hi {FIRST_NAME}, welcome to {ACCOUNT_NAME}!

Your enrollment code is {ENROLLMENT_CODE}. Please complete
your registration by {DEADLINE_DATE}.

Best regards,
{SENDER_NAME}
```

When this template is sent to a contact, the processor replaces each variable with that contact's actual data:

```
Hi Sarah, welcome to Turumba Academy!

Your enrollment code is TRB-2024-0042. Please complete
your registration by March 15, 2026.

Best regards,
Abebe
```

### Variable Sources

Variables are resolved from multiple sources, in priority order:

1. **Contact fields** — `{FIRST_NAME}`, `{LAST_NAME}`, `{EMAIL}`, `{PHONE}` — pulled from the contact's profile in the Account API
2. **Contact custom attributes** — Any custom attribute stored on the contact (e.g., `{ENROLLMENT_DATE}`, `{PROGRAM_NAME}`)
3. **Account fields** — `{ACCOUNT_NAME}` — pulled from the sending account's profile
4. **Sender fields** — `{SENDER_NAME}`, `{SENDER_EMAIL}` — pulled from the user who initiated the send
5. **System fields** — `{CURRENT_DATE}`, `{CURRENT_TIME}` — generated at send time
6. **Custom values** — Variables provided explicitly at send time (e.g., `{VERIFICATION_CODE}`, `{MEETING_LINK}`)

If a variable cannot be resolved, the template's `fallback_strategy` determines what happens:

| Strategy | Behavior |
|----------|----------|
| **`keep_placeholder`** | Leave `{FIRST_NAME}` as-is in the rendered message (default) |
| **`use_default`** | Replace with the value from `default_values` (e.g., "there" instead of `{FIRST_NAME}`) |
| **`skip_contact`** | Skip sending to that contact entirely (useful when the variable is critical) |

Default values are stored per variable in the `default_values` JSONB field:
```json
{ "FIRST_NAME": "there", "ENROLLMENT_CODE": "" }
```

### Template Management

- **Create templates** — Write a message body with variables, give it a name and optional category
- **Edit templates** — Modify existing templates; changes do not affect previously sent messages
- **Preview templates** — See how the message will look with example contact data
- **Organize templates** — Group templates by category (e.g., "Onboarding", "Reminders", "Promotions")
- **Channel-specific templates** — Some channels (WhatsApp) require pre-approved templates; Turumba tracks approval status per channel

### Variable Extraction

When a template is created or its body is updated, the system automatically extracts all `{VARIABLE_NAME}` placeholders and stores them in the `variables` JSONB field. This allows the frontend to display which variables a template uses without re-parsing the body.

Example for body `"Hi {FIRST_NAME}, your code is {CODE}"`:
```json
["FIRST_NAME", "CODE"]
```

### API Endpoints

| Method | Endpoint | Description |
|--------|----------|-------------|
| `POST` | `/v1/templates/` | Create a new template |
| `GET` | `/v1/templates/` | List templates (filtered, sorted, paginated) |
| `GET` | `/v1/templates/{id}` | Get a single template by ID |
| `PATCH` | `/v1/templates/{id}` | Update a template |
| `DELETE` | `/v1/templates/{id}` | Delete a template |

All endpoints require authentication. List endpoint is scoped to the user's accounts via the gateway's `x-account-ids` header.

### Filtering and Sorting

Templates support the platform's standard filter syntax: `?filter=field:op:value&sort=field:order`

| Field | Allowed Filter Operations | Sortable |
|-------|--------------------------|----------|
| `id` | `eq` | No |
| `account_id` | `eq`, `in` | No |
| `name` | `eq`, `contains`, `icontains` | Yes |
| `category` | `eq`, `in` | Yes |
| `channel_type` | `eq`, `in` | Yes |
| `language` | `eq`, `in` | No |
| `is_active` | `eq` | No |
| `approval_status` | `eq`, `in` | No |
| `fallback_strategy` | `eq` | No |
| `created_by_user_id` | `eq` | No |
| `created_at` | `ge`, `le`, `range` | Yes |
| `updated_at` | `ge`, `le`, `range` | Yes |

**Example queries:**
```bash
# All templates in the "Onboarding" category
GET /v1/templates/?filter=category:eq:Onboarding&sort=name:asc

# Active WhatsApp-approved templates
GET /v1/templates/?filter=channel_type:eq:whatsapp&filter=approval_status:eq:approved&filter=is_active:eq:true

# Search templates by name
GET /v1/templates/?filter=name:icontains:welcome&sort=created_at:desc

# Templates created by a specific user
GET /v1/templates/?filter=created_by_user_id:eq:{uuid}&sort=updated_at:desc
```

---

## 3. Group Messaging

Group messaging lets users send a single message to an entire contact group at once. The system handles iterating through all contacts in the group, rendering template variables for each recipient, and dispatching individual messages through the selected delivery channel.

**Database:** PostgreSQL — group messages are relational (FK to accounts, channels, templates; referenced by individual messages via `group_message_id`) and require ACID guarantees for progress counter updates. Recipient targeting and custom variable values are stored in JSONB.

### Group Message Data Model

```
group_messages (PostgreSQL)
├── id (UUID, PK)
├── account_id (UUID, indexed)              — tenant isolation
├── channel_id (UUID, nullable, indexed)    — which delivery channel to send through
├── template_id (UUID, nullable, indexed)   — which template to use (may be auto-created)
├── created_by_user_id (UUID, nullable)     — who initiated the send
├── name (string, nullable)                 — user-defined name for the group send
├── status (string, indexed)                — "draft", "queued", "processing", "completed", "partially_failed", "failed", "cancelled"
├── contact_group_ids (JSONB)               — list of contact group UUIDs to target
├── exclude_contact_ids (JSONB, nullable)   — specific contacts to exclude
├── total_recipients (integer)              — total number of contacts targeted
├── sent_count (integer)                    — messages handed off to provider
├── delivered_count (integer)               — messages confirmed delivered
├── failed_count (integer)                  — messages that failed
├── pending_count (integer)                 — messages still waiting
├── scheduled_at (timestamp, nullable)      — for scheduled group sends
├── started_at (timestamp, nullable)        — when processing began
├── completed_at (timestamp, nullable)      — when all messages were dispatched
├── custom_values (JSONB, nullable)         — template variable overrides for all recipients
├── metadata (JSONB, nullable)              — additional metadata
├── created_at (timestamp)
└── updated_at (timestamp)
```

### Group Message Statuses

```
Draft ──→ Queued → Processing → Completed
   │                    │
   │                    ├→ Partially Failed
   │                    │
   │                    └→ Failed
   │
   └→ Cancelled (can also cancel from Queued or Processing)
```

| Status | Meaning |
|--------|---------|
| **Draft** | Created but not yet submitted for sending |
| **Queued** | Submitted and waiting to be processed |
| **Processing** | Currently iterating through contacts and dispatching messages |
| **Completed** | All messages dispatched successfully |
| **Partially Failed** | Some messages delivered, some failed |
| **Failed** | All messages failed |
| **Cancelled** | Cancelled by user before or during processing |

### Auto-Template Creation from Message Body

Users can create a group message in two ways:

1. **Pass `template_id`** — Use an existing template
2. **Pass `message_body`** — Provide raw message text directly

When `message_body` is provided instead of `template_id`, the system automatically creates a new `Template` record — extracting any `{VARIABLE_NAME}` placeholders, setting the category to `"auto-generated"` — and links it to the group message via `template_id`. This gives users a shortcut without requiring a separate template creation step. The auto-created template is also reusable for future sends.

The request must provide **either** `template_id` **or** `message_body`, not both.

### How Group Messaging Works

```
User composes message (template)
         │
         ▼
Selects contact group + delivery channel
         │
         ▼
Submits group send
         │
         ▼
Messaging API creates a Group Message record
         │
         ▼
Processor iterates through group contacts
         │
         ├─→ Contact 1: Render template → Send via channel → Record status
         ├─→ Contact 2: Render template → Send via channel → Record status
         ├─→ Contact 3: Render template → Send via channel → Record status
         └─→ ...
         │
         ▼
Group Message status updated with aggregate results
```

### Group Message Features

- **Contact group selection** — Choose one or more contact groups or segments as recipients
- **Channel selection** — Choose which delivery channel to send through, or use each contact's preferred channel
- **Template rendering** — Each contact receives a personalized version of the message
- **Progress tracking** — Real-time progress: `3,421 / 5,000 delivered` with counts per status (delivered, failed, pending)
- **Skip duplicates** — If a contact appears in multiple selected groups, they receive the message only once
- **Exclude contacts** — Optionally exclude specific contacts or segments from a group send
- **Rate limiting** — Messages are dispatched respecting the channel's configured rate limits to avoid provider throttling

### Group Message Record

Each group send creates a parent record that tracks total recipient count, delivered/failed/pending counts, start and completion time, which template and channel were used, and who initiated the send. Individual messages within the group are linked back to this parent record via `group_message_id`, so users can drill down from the group summary to see per-contact delivery status.

### Custom Values

Template variable values provided at send time that apply to **all** recipients (e.g., a shared meeting link or event date):

```json
{ "MEETING_LINK": "https://meet.example.com/abc123", "EVENT_DATE": "March 20, 2026" }
```

These are merged with contact-specific variable sources during template rendering.

### API Endpoints

| Method | Endpoint | Description |
|--------|----------|-------------|
| `POST` | `/v1/group-messages/` | Create a new group message |
| `GET` | `/v1/group-messages/` | List group messages (filtered, sorted, paginated) |
| `GET` | `/v1/group-messages/{id}` | Get a single group message by ID (includes progress counters) |
| `PATCH` | `/v1/group-messages/{id}` | Update a group message (edit draft, cancel, etc.) |
| `DELETE` | `/v1/group-messages/{id}` | Delete a group message |

All endpoints require authentication. List endpoint is scoped to the user's accounts via the gateway's `x-account-ids` header.

### Filtering and Sorting

Group messages support the platform's standard filter syntax: `?filter=field:op:value&sort=field:order`

| Field | Allowed Filter Operations | Sortable |
|-------|--------------------------|----------|
| `id` | `eq` | No |
| `account_id` | `eq`, `in` | No |
| `channel_id` | `eq`, `in` | No |
| `template_id` | `eq` | No |
| `name` | `eq`, `contains`, `icontains` | Yes |
| `status` | `eq`, `in` | Yes |
| `created_by_user_id` | `eq` | No |
| `total_recipients` | `ge`, `le` | Yes |
| `scheduled_at` | `ge`, `le`, `range` | Yes |
| `started_at` | `ge`, `le`, `range` | Yes |
| `completed_at` | `ge`, `le`, `range` | Yes |
| `created_at` | `ge`, `le`, `range` | Yes |
| `updated_at` | `ge`, `le`, `range` | Yes |

**Example queries:**
```bash
# All completed group sends
GET /v1/group-messages/?filter=status:eq:completed&sort=completed_at:desc

# Group messages currently processing
GET /v1/group-messages/?filter=status:in:queued,processing&sort=created_at:asc

# Scheduled group sends in the next 7 days
GET /v1/group-messages/?filter=scheduled_at:range:2026-02-08,2026-02-15&sort=scheduled_at:asc

# Large group sends (1000+ recipients)
GET /v1/group-messages/?filter=total_recipients:ge:1000&sort=total_recipients:desc
```

---

## 4. Scheduled Messages

Scheduled messages allow users to compose a message now and have it delivered at a specific future date and time. This works for both single messages and group messages, with support for one-time and recurring schedules with timezone awareness.

**Database:** PostgreSQL — scheduled messages are relational (FK to accounts, channels, templates; creates messages or group messages on trigger) and require consistent state for recurring schedule tracking. Recipient targeting and recurrence configuration are stored in JSONB.

### Scheduled Message Data Model

```
scheduled_messages (PostgreSQL)
├── id (UUID, PK)
├── account_id (UUID, indexed)              — tenant isolation
├── channel_id (UUID, nullable, indexed)    — which delivery channel to send through
├── template_id (UUID, nullable, indexed)   — which template to use (may be auto-created)
├── created_by_user_id (UUID, nullable)     — who created the schedule
├── name (string, nullable)                 — user-defined name for the schedule
├── status (string, indexed)                — "pending", "triggered", "completed", "failed", "cancelled", "paused"
├── message_body (text, nullable)           — direct message text (alternative to template_id)
├── custom_values (JSONB, nullable)         — template variable overrides for all recipients
├── send_type (string, indexed)             — "single" or "group"
├── delivery_address (string, nullable)     — single: phone, email, username, etc.
├── contact_id (UUID, nullable)             — single: specific contact
├── contact_group_ids (JSONB, nullable)     — group: list of contact group UUIDs
├── exclude_contact_ids (JSONB, nullable)   — group: contacts to exclude
├── scheduled_at (timestamp)                — when to send (first trigger for recurring)
├── timezone (string, nullable)             — e.g., "Africa/Addis_Ababa"
├── is_recurring (boolean)                  — one-time or recurring
├── recurrence_rule (string, nullable)      — e.g., "daily", "weekly:mon,wed,fri", "monthly:15"
├── recurrence_end_at (timestamp, nullable) — when to stop recurring (null = indefinite)
├── last_triggered_at (timestamp, nullable) — when last triggered
├── next_trigger_at (timestamp, nullable, indexed) — when next trigger is due
├── trigger_count (integer)                 — how many times triggered so far
├── message_id (UUID, nullable)             — resulting message record (single sends)
├── group_message_id (UUID, nullable)       — resulting group message record (group sends)
├── metadata (JSONB, nullable)              — additional metadata
├── created_at (timestamp)
└── updated_at (timestamp)
```

### Send Type: Single vs Group

Each scheduled message targets either a single recipient or a contact group:

| Field | Single | Group |
|-------|--------|-------|
| `delivery_address` | Required (phone, email, etc.) | Not used |
| `contact_id` | Optional (link to contact) | Not used |
| `contact_group_ids` | Not used | Required (list of group UUIDs) |
| `exclude_contact_ids` | Not used | Optional |
| **On trigger creates** | `Message` record | `GroupMessage` record |

### How Scheduling Works

When a user creates a scheduled message:

1. The scheduled message is created with status **Pending** and `next_trigger_at` set to `scheduled_at`
2. The schedule waits until the trigger time arrives
3. At the trigger time, the processor creates the actual Message (single) or GroupMessage (group) record
4. For **one-time** schedules: status transitions to Completed
5. For **recurring** schedules: `next_trigger_at` is recomputed based on `recurrence_rule`, and the status returns to Pending

### Scheduled Message Statuses

**One-time schedule:**
```
Pending → Triggered → Completed
   │          │
   │          └→ Failed
   └→ Cancelled
```

**Recurring schedule:**
```
Pending → Triggered → Pending (next_trigger_at updated) → ... → Completed (end date reached)
   │          │
   ├→ Paused → Pending (resumed)
   └→ Cancelled
```

| Status | Meaning |
|--------|---------|
| **Pending** | Waiting for scheduled time to arrive |
| **Triggered** | Currently being processed (creating message/group message) |
| **Completed** | Delivered successfully, or all recurrences finished |
| **Failed** | Trigger failed (e.g., invalid template, channel unavailable) |
| **Cancelled** | Cancelled by user before triggering |
| **Paused** | Recurring schedule temporarily paused |

### Recurring Schedules

Recurring schedules use a simple `recurrence_rule` format:

| Rule | Meaning |
|------|---------|
| `daily` | Every day at the same time |
| `weekly:mon,wed,fri` | Every Monday, Wednesday, Friday |
| `monthly:15` | 15th of every month |
| `monthly:1,15` | 1st and 15th of every month |

The `scheduled_at` defines the first trigger time and the time-of-day for all recurring triggers. `recurrence_end_at` is optional — if not set, the schedule recurs indefinitely until cancelled or paused.

### Scheduling Features

- **One-time or recurring** — Schedule a single delivery or set up a repeating cadence
- **Timezone support** — Schedule in the user's timezone or the recipient's timezone
- **Edit before delivery** — Modify or cancel a scheduled message any time before its trigger time
- **Pause and resume** — Temporarily pause a recurring schedule without cancelling it
- **View scheduled queue** — See all upcoming scheduled messages sorted by `next_trigger_at`
- **Auto-template creation** — Pass `message_body` instead of `template_id` for a quick setup (same as Group Messages)

### API Endpoints

| Method | Endpoint | Description |
|--------|----------|-------------|
| `POST` | `/v1/scheduled-messages/` | Create a new scheduled message |
| `GET` | `/v1/scheduled-messages/` | List scheduled messages (filtered, sorted, paginated) |
| `GET` | `/v1/scheduled-messages/{id}` | Get a single scheduled message by ID |
| `PATCH` | `/v1/scheduled-messages/{id}` | Update (edit, cancel, pause, resume) |
| `DELETE` | `/v1/scheduled-messages/{id}` | Delete a scheduled message |

All endpoints require authentication. List endpoint is scoped to the user's accounts via the gateway's `x-account-ids` header.

### Filtering and Sorting

Scheduled messages support the platform's standard filter syntax: `?filter=field:op:value&sort=field:order`

| Field | Allowed Filter Operations | Sortable |
|-------|--------------------------|----------|
| `id` | `eq` | No |
| `account_id` | `eq`, `in` | No |
| `channel_id` | `eq`, `in` | No |
| `template_id` | `eq` | No |
| `name` | `eq`, `contains`, `icontains` | Yes |
| `status` | `eq`, `in` | Yes |
| `send_type` | `eq` | No |
| `is_recurring` | `eq` | No |
| `created_by_user_id` | `eq` | No |
| `scheduled_at` | `ge`, `le`, `range` | Yes |
| `next_trigger_at` | `ge`, `le`, `range` | Yes |
| `last_triggered_at` | `ge`, `le`, `range` | Yes |
| `created_at` | `ge`, `le`, `range` | Yes |
| `updated_at` | `ge`, `le`, `range` | Yes |

**Example queries:**
```bash
# All pending schedules, soonest first
GET /v1/scheduled-messages/?filter=status:eq:pending&sort=next_trigger_at:asc

# Recurring schedules only
GET /v1/scheduled-messages/?filter=is_recurring:eq:true&sort=next_trigger_at:asc

# Schedules due in the next 24 hours
GET /v1/scheduled-messages/?filter=next_trigger_at:range:2026-02-08,2026-02-09&sort=next_trigger_at:asc

# Failed schedules that need attention
GET /v1/scheduled-messages/?filter=status:eq:failed&sort=scheduled_at:desc
```

---

## 5. Event Infrastructure

The messaging system uses an event-driven architecture to decouple the API layer from background processing. When Group Messages or Scheduled Messages are created or updated, domain events are published to a message broker (RabbitMQ) via a **Transactional Outbox** pattern. This guarantees reliable, at-least-once event delivery with zero event loss.

### Three-Layer Architecture

The event pipeline consists of three layers:

```
Layer 1: EventBus (in-memory, request-scoped)
    Controllers emit domain events during business logic.
    Events are collected in memory — nothing is persisted yet.
         │
         ▼
Layer 2: Transactional Outbox (PostgreSQL)
    OutboxMiddleware flushes events from the EventBus to the
    outbox_events table in the SAME DB transaction as the entity.
    Guarantees atomicity — entity + events succeed or fail together.
         │
         ▼
Layer 3: Outbox Worker → RabbitMQ
    A separate background process polls the outbox table and
    publishes pending events to RabbitMQ. Events are routed
    to processing queues by type.
         │
         ▼
    Consumers (Group Message Processor, Schedule Trigger, etc.)
```

### Why This Pattern

The **dual-write problem** occurs when an application needs to write to a database AND publish to a message broker — if either operation fails, the system is left in an inconsistent state. The Transactional Outbox solves this by making event persistence part of the same database transaction as the entity change:

| Concern | How It's Handled |
|---------|-----------------|
| **Atomicity** | Entity + outbox event written in one DB transaction — both succeed or both fail |
| **No event loss** | Events persist in the outbox even if RabbitMQ is down — published when broker recovers |
| **Separation of concerns** | Controllers emit events without knowing about the outbox or RabbitMQ |
| **Testability** | Mock the EventBus to assert events emitted without needing a real DB or broker |
| **Idempotency** | Events carry a unique `id` — consumers handle at-least-once delivery |
| **Scalability** | Multiple outbox workers can run concurrently with `FOR UPDATE SKIP LOCKED` |
| **Observability** | Outbox table is queryable — monitor pending, published, and failed events |

### EventBus

The EventBus is a **request-scoped, in-memory** event collector. Each HTTP request gets its own EventBus instance. Controllers call `event_bus.emit()` to record that something happened — the events are collected in a Python list but **not yet persisted**.

This keeps controllers clean — they express domain intent ("a group message was queued") without knowing how events are stored or delivered.

```python
# Controller emits an event — no persistence, no side effects
event_bus.emit(DomainEvent(
    event_type="group_message.queued",
    aggregate_type="group_message",
    aggregate_id=group_message.id,
    payload={ "id": "...", "status": "queued", "previous_status": "draft" },
))
```

### OutboxMiddleware

After the controller finishes, the router calls `OutboxMiddleware.flush()` which:

1. Reads all collected events from the EventBus via `collect()`
2. Creates `OutboxEvent` records in the DB session (not committed yet)
3. Enriches each event payload with standard metadata (timestamp, user_id, request_id)

The router then calls `db.commit()` — this single commit atomically persists both the entity changes AND the outbox events. If the commit fails, both are rolled back.

```python
# Router pattern: controller → flush → commit → notify
result = await controller.create(data, db, event_bus=event_bus)
await outbox.flush(db, event_bus, user_id=current_user_id)
await db.commit()                          # atomic: entity + outbox events
await pg_notify('outbox_channel')          # wake up worker (fire-and-forget)
```

### Outbox Events Data Model

```
outbox_events (PostgreSQL)
├── id (UUID, PK)
├── event_type (string, indexed)           — "group_message.queued", "scheduled_message.created"
├── aggregate_type (string, indexed)       — "group_message", "scheduled_message"
├── aggregate_id (UUID, indexed)           — the entity ID
├── payload (JSONB)                        — event data with standard envelope fields
├── status (string, indexed)               — "pending", "published", "failed"
├── retry_count (integer)                  — publish attempts so far
├── max_retries (integer)                  — max attempts before marking failed (default: 10)
├── published_at (timestamp, nullable)     — when successfully published to RabbitMQ
├── error_message (text, nullable)         — last publish error
├── created_at (timestamp)
└── updated_at (timestamp)
```

### Event Types

#### Group Message Events

| Event Type | Trigger | Key Payload Fields |
|------------|---------|-------------------|
| `group_message.created` | GroupMessage created | id, account_id, channel_id, template_id, status, contact_group_ids, total_recipients, scheduled_at |
| `group_message.queued` | Status → `queued` | id, account_id, status, previous_status |
| `group_message.cancelled` | Status → `cancelled` | id, account_id, status, previous_status |

#### Scheduled Message Events

| Event Type | Trigger | Key Payload Fields |
|------------|---------|-------------------|
| `scheduled_message.created` | ScheduledMessage created | id, account_id, channel_id, template_id, send_type, status, scheduled_at, timezone, is_recurring, recurrence_rule, next_trigger_at |
| `scheduled_message.updated` | Schedule config changed | id, account_id, scheduled_at, timezone, is_recurring, recurrence_rule, next_trigger_at, changed_fields |
| `scheduled_message.cancelled` | Status → `cancelled` | id, account_id, status, previous_status |
| `scheduled_message.paused` | Status → `paused` | id, account_id, status, previous_status |
| `scheduled_message.resumed` | Status `paused` → `pending` | id, account_id, status, previous_status, next_trigger_at |

All event payloads include standard envelope fields added by the OutboxMiddleware: `event_type`, `aggregate_type`, `aggregate_id`, `timestamp`, `user_id`.

### Outbox Worker

The outbox worker is a **standalone Python process** that bridges the outbox table and RabbitMQ:

1. Connects to PostgreSQL and listens on `pg_notify('outbox_channel')` for instant wake-up (with a 5-second poll fallback)
2. Reads pending events in batches of 100 using `FOR UPDATE SKIP LOCKED` (safe for concurrent workers)
3. Publishes each event to the RabbitMQ `messaging` exchange with `routing_key = event_type`
4. Marks successfully published events as `published`
5. On failure: increments `retry_count` with exponential backoff. After 10 retries, marks as `failed` for manual investigation
6. Periodically cleans up published events older than 7 days

### RabbitMQ Topology

```
                     ┌──────────────────────┐
                     │  Exchange: messaging  │
                     │  Type: topic          │
                     │  Durable: yes         │
                     └──────────┬───────────┘
                                │
             Routing by event_type pattern
                                │
         ┌──────────────────────┼──────────────────────┐
         │                      │                      │
         ▼                      ▼                      ▼
┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐
│ group_message    │  │ scheduled_message│  │ messaging_audit  │
│ _processing      │  │ _processing      │  │ (optional)       │
│                  │  │                  │  │                  │
│ Bind: group_     │  │ Bind: scheduled_ │  │ Bind: # (all)    │
│ message.*        │  │ message.*        │  │                  │
└──────────────────┘  └──────────────────┘  └──────────────────┘
         │                      │
         ▼                      ▼
  Group Message          Schedule Trigger
  Processor              Service
  (future)               (future)
```

| Component | Type | Purpose |
|-----------|------|---------|
| `messaging` | Topic exchange (durable) | Routes all messaging domain events by event_type pattern |
| `group_message_processing` | Queue (durable) | Receives `group_message.*` events for dispatch processing |
| `scheduled_message_processing` | Queue (durable) | Receives `scheduled_message.*` events for trigger processing |
| `messaging_audit` | Queue (durable, optional) | Receives all events (`#`) for debugging and audit logging |
| `messaging.dlx` | Topic exchange (durable) | Dead letter exchange for messages that fail consumer processing |
| `messaging.dlq` | Queue (durable) | Dead letter queue bound to `messaging.dlx` for investigation |

New consumers can bind to the `messaging` exchange at any time without changing any producer code — the topic exchange routes events by pattern matching on `event_type`.

### Full Event Lifecycle Example

A user creates a group message with status `queued`:

```
1. POST /v1/group-messages/  { status: "queued", ... }

2. Controller:
   ├── Creates GroupMessage entity in DB session
   ├── Auto-creates template if message_body provided
   └── event_bus.emit(DomainEvent("group_message.created", ...))

3. Router:
   ├── outbox.flush(db, event_bus) → writes OutboxEvent to DB session
   ├── db.commit() → ATOMIC: GroupMessage + OutboxEvent
   └── pg_notify('outbox_channel')

4. Outbox Worker:
   ├── Wakes up via pg_notify
   ├── SELECT outbox_events WHERE status = 'pending'
   ├── Publish to RabbitMQ: routing_key = "group_message.created"
   └── UPDATE status = 'published'

5. RabbitMQ routes to "group_message_processing" queue

6. Group Message Processor (future consumer):
   ├── Fetches GroupMessage, Template, Contacts
   ├── Iterates contacts, renders templates, creates Messages
   ├── Updates progress counters
   └── ACKs the broker message
```

Total latency from API response to outbox worker publish: typically **< 100ms** (pg_notify + worker + broker routing).

---

## Relationship Between Features

All messaging features are built on the same foundation:

```
                    Delivery Channels
                    (where messages go)
                           │
                           ▼
    ┌──────────────────────────────────────────┐
    │              Template Messages            │
    │         (what the message says)           │
    └──────────────────────────────────────────┘
                           │
            ┌──────────────┼──────────────┐
            │              │              │
            ▼              ▼              ▼
      Single Message  Group Message  Scheduled Message
                           │              │
                           └──────┬───────┘
                                  │
                           EventBus → Outbox
                                  │
                                  ▼
                        RabbitMQ (messaging)
                                  │
                    ┌─────────────┼─────────────┐
                    ▼             ▼              ▼
              Group Msg     Schedule       Audit Log
              Processor     Trigger
                    │             │
                    └──────┬──────┘
                           │
                           ▼
                    Message Record
                   (status tracking)
```

- **Delivery Channels** are required — you need at least one before you can send anything
- **Template Messages** are optional for single messages but required for group messaging (each contact gets a personalized version)
- **Group Messaging** and **Scheduled Messages** are different ways to trigger the same underlying message send
- **Event Infrastructure** connects Group Messages and Scheduled Messages to background processors via EventBus → Transactional Outbox → RabbitMQ
- Every message — regardless of how it was triggered — results in a **Message Record** with full status tracking
